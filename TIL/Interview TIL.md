# 면접 기록들

1. overriding과 overoading 이란?
- overriding은 상위 클래스(super class)의 상속할 메소드, 프로퍼티 서브스크립트를 하위 클래스에서 원하는 대로 구현(재정의) 하는 것을 의미한다 override 키워드를 메소드 앞에 붙여서 선언하여 해당 문법을 사용할 수 있다
- 프로퍼티를 overriding 할 경우 저장 프로퍼티만 선언할 수 있고 타입을 반드시 명시해야 한다
- overloading은 매개 변수, 매개 변수의 타입, 리턴 타입을 다르게 넣어 한 객체 내에 동명의 함수를 여러개 선언하는 것을 의미한다

2. final을 사용하는 이유? 
- class 자체가 상속되는 것을 막고 싶을 때
- overriding 이 필요하지 않을 때 사용
 
2-1. final을 사용함으로써 얻을 수 있는 이점은?
- 성능이 더 올라간다 

2-2. 성능이 어떻게 하여 더 올라가는가?
- final 키워드가 적용된 메서드는 Static Dispatch로 결정되어 컴파일 시점에 어떤 메서드를 실행할 지 결정할 수 있기 때문에 성능상 이점을 가질 수 있다
2-3. Dispatch?
- Dispatch란 어떤 메소드를 호출할 것인가를 결정을 짓는 메커니즘을 의미힌다.
- Static Dispatch, Dynamic Dispatch가 있고 Static은 컴파일 시점에 어떤 메소드가 사용될 지 결정되는 것, Dynamic은 런타임 때 vTable(가상 메소드 테이블), 오버라이딩에 따라 실행 시점에 어떤 메서드가 실행될 지 결정되는 것. 기본적으로 struct와 enum은 값타입이기에 static 으로 작동한다
- 클래스는 메소드, 프로퍼티를 상위 클래스로부터 override 할 수 있기에 런타임 시에 주소를 통해 호출 혹은 접근을 통해 어떤 메서드와 프로퍼티를 호출할지 정해진다 이 과정을 Dynamic Dispatch라 부르고 이 과정에서 overhead가 발생하여 static dispatch에 비해 성능이 많이 요구된다.


3. 참조에 대하여 설명해라
- 차례로 변수 a, b를 선언 하여 b에 a를 대입(할당)한 후 a를 변경했을 때 b도 영향을 받아 a,b가 같은 값을 가지고 있는 상태를 참조라고 한다

3-1. Swift에서 참조 타입이란?
- 값을 별도의 메모리(heap)에 저장하고 그 주소와 변수명을 stack에 저장하는 타입을 의미한다
- 참조 타입은 다른 변수에 할당하면 인스턴스가 아닌 주소값을 복사하고 새로 할당된 변수와 원래의 변수 모두 같은 주소를 가르키게 된다
- class 키워드를 사용한 모든 타입은 참조 타입이 된다

4. class와 struct에 대한 설명
- class는 참조 타입(Reference Type) struct는 값 타입(Value Type)
- class는 상속이 가능하지만 struct는 불가
- 둘다 protocol 채택 가능
- 프로퍼티 선언 가능
- 생성자를 통해 초기값 제어 가능

5. 순환 참조란?
- 두 가지 이상의 객체가 서로에 대한 강한 참조 상태를 가지고 있을 떄 발생하는 현상
- 이 상태가 발발하면 서로에 대한 참조가 해제되지 않기때문에 메모리에서 유지되며 메모리 누수(Memory Leak)을 유발한다
- weak, unowned를 통해 해결한다
- 둘다 참조카운트를 올리진 않지만 unowned는 참조 객체가 존재한다는(해제되도 그 주소를 바라봄) 보장된다는 전제가 있기 때문에 weak를 사용하는걸 지향한다

6. defer?
- defer 안에 코드 블럭의 실행을 scope 종료 직전까지 연기 시키는 것(가장 마지막에 호출) 
- Stack 구조이기 때문에 여러개가 선언될 경우 가장 마지막에 작성된 코드블럭 부터 호출된다

7. Queue 자료구조에 대하여
- 기본적으로 FIFO 선입 선출의 성격을 가진 자료구조
- 한쪽 끝에서는 삽입 연산만 반대쪽 끝에서는 삭제만 가능한 구조
- 마트의 계산대줄을 생각해보면 이해가 쉽다
- removeFirst(), append(_:) 등의 함수가 이 구조에서 요구하는 함수와 비슷하다

8. ARC에 대하여 설명
- 자동으로 메모리 관리를 해주는 시스템
- 객체에 대한 참조 카운트를 관리하고 0이 되면 자동으로 메모리를 해제해주는 시스템

8-1. ARC가 구체적으로 어떻게 관리를 하는가?
- 컴파일 단계에 언제 참조되고 해제되는지 분석하고 참조와 해제를 설정한다 이 설정은 런타임때 실행된다
- retain, release를 통해 referenceCount를 증감시키다가 count 가 0이 되면 deinit 을 통해 해제 시킨다
- retain 증가, releases는 감소를 의미한다 

9. 화면 이동에서 ModalPresentationStyle에서 Over가 붙은 키워드의 의미
- Over가 붙으면 Presenting을 시키는 Controller의 계층이 사라지지 않고 계속 존재한다
- WillDisAppear, DidDisAppear가 호출되지 않음
- Over가 빠진 같은 키워는 계층이 사라짐, WillDisAppear, DidDisAppear이 호출됨

10. AutoLayout 설정 시 Leading과 left의 차이점은?
- left는 말 그대로 무조건적인 왼쪽을 의미하고 Leading은 글자의 시작점(가장자리)를 의미한다 
- Leading은 HIG에 맞춰서 글자를 오른쪽에서 왼쪽으로 읽는 국가 설정의 디바이스에서는 오른쪽으로 지정된다
