# Closure
- 일회용 함수를 제작할 수 있는 구문
- 자신이 정의되었던 문맥(Context)으로부터 모든 상수와 변수의 값을 캡쳐(Capture)하거나 레퍼런스를 저장하는 

## 클로저 객체라고 지칭되는 것
### 1. 전역 함수
- 이름이 있고 주변 환경에서 캡쳐할 어떤 것도 없는 클로저
### 2. 중첩 함수
- 이름이 있으며 자신을 둘러싼 함수로부터 값을 캡쳐할 수 있는 클로저
### 3. 클로저 표현식
- 이름이 없으며 주변 환경으로부터 값을 캡쳐할 수 있는 경량 문법으로 작성된 클로저

```swift
{ (매개변수) in 
  // 실행구문
}

let f = { () -> Void in 
    print("클로저 실행")
}

f()
// 클로저 실행

let c = { (s1: Int, s2: String) in 
    print("s1: \(s1), s2: \(s2)")
}

c(1, "closure")
//  s1: 1, s2: closure
/*
{ (s1: Int, s2: String) in 
    print("s1: \(s1), s2: \(s2)")
}(1, "closure")
*/

```

## @escaping
- 인자값으로 전달된 클로저를 저장해 두었다가 나중에 다른 곳에서도 실행할 수 있도록 허용해주는 속성
- 기본적으로 함수의 인자값으로 전달된 클로저는 탈출 불가의 속성을 가진다 이는 해당 클로저를 함수 내에서 직접 실행을 위해서만 사용해야 하는것을 의미하며 이 떄문에 함수 내부라 할지라도 변수나 상수에 대입할 수 없다
- 대입을 허용한다면 내부 함수를 통한 캡쳐(Capture) 기능을 이용하여 클로저가 함수 바깥으로 탈출 할 수 있기 때문

```swift
var sampleClosure: () -> Void = { }
func callback(fn: () -> Void)  {
    sampleClosure = fn // 에러
    
}

func callback2(fn: @escaping () -> Void)  {
    sampleClosure = fn
    sampleClosure() // <- 에러 
}

```
## @autoescape


## 용어
### 클로저에서 탈출이란?
- 함수 내부 범위를 벗어나서 실행되는 것
- 탈출 불가(non-escape)하게 관리함으로 얻는 이점은 컴파일러가 코드를 최적화하는 과정에서의 성능향상을 도모하기 위해 탈출 할 수 없다는 뜻은 컴파일러가 더 이상 메모리의 관리상의 관여할 필요가 없기 때문  
- 탈출 불가 클로저 내에서는 self 키워드 사용이 가능 약한 참조를 사용해야할 필요가 없다
- 탈출 가능 함으로써 얻을 수 있는 것은 해당 클로져를 외부 변수/상수에 저장이 가능하고 함수가 호출이 종료된 후에도 클로저 실행이 가능한 이점이 있다
