# 면접 기록들

1. overriding과 overoading 이란?
- overriding은 상위 클래스(super class)의 상속할 메소드, 프로퍼티 서브스크립트를 하위 클래스에서 원하는 대로 구현(재정의) 하는 것을 의미한다 override 키워드를 메소드 앞에 붙여서 선언하여 해당 문법을 사용할 수 있다
- 프로퍼티를 overriding 할 경우 저장 프로퍼티만 선언할 수 있고 타입을 반드시 명시해야 한다
- overloading은 매개 변수, 매개 변수의 타입, 리턴 타입을 다르게 넣어 한 객체 내에 동명의 함수를 여러개 선언하는 것을 의미한다

2. final을 사용하는 이유? 
- class 자체가 상속되는 것을 막고 싶을 때
- overriding 이 필요하지 않을 때 사용
 
2-1. final을 사용함으로써 얻을 수 있는 이점은?
- 성능이 더 올라간다 

2-2. 성능이 어떻게 하여 더 올라가는가?
- final 키워드가 적용된 메서드는 Static Dispatch로 결정되어 컴파일 시점에 어떤 메서드를 실행할 지 결정할 수 있기 때문에 성능상 이점을 가질 수 있다
2-3. Dispatch?
- Dispatch란 어떤 메소드를 호출할 것인가를 결정을 짓는 메커니즘을 의미힌다.
- Static Dispatch, Dynamic Dispatch가 있고 Static은 컴파일 시점에 어떤 메소드가 사용될 지 결정되는 것, Dynamic은 런타임 때 vTable(가상 메소드 테이블), 오버라이딩에 따라 실행 시점에 어떤 메서드가 실행될 지 결정되는 것. 기본적으로 struct와 enum은 값타입이기에 static 으로 작동한다
- 클래스는 메소드, 프로퍼티를 상위 클래스로부터 override 할 수 있기에 런타임 시에 주소를 통해 호출 혹은 접근을 통해 어떤 메서드와 프로퍼티를 호출할지 정해진다 이 과정을 Dynamic Dispatch라 부르고 이 과정에서 overhead가 발생하여 static dispatch에 비해 성능이 많이 요구된다.


3. 참조에 대하여 설명해라
- 차례로 변수 a, b를 선언 하여 b에 a를 대입(할당)한 후 a를 변경했을 때 b도 영향을 받아 a,b가 같은 값을 가지고 있는 상태를 참조라고 한다

3-1. Swift에서 참조 타입이란?
- 값을 별도의 메모리(heap)에 저장하고 그 주소와 변수명을 stack에 저장하는 타입을 의미한다
- 참조 타입은 다른 변수에 할당하면 인스턴스가 아닌 주소값을 복사하고 새로 할당된 변수와 원래의 변수 모두 같은 주소를 가르키게 된다
- class 키워드를 사용한 모든 타입은 참조 타입이 된다

4. class와 struct에 대한 설명
- class는 참조 타입(Reference Type) struct는 값 타입(Value Type)
- class는 상속이 가능하지만 struct는 불가
- 둘다 protocol 채택 가능
- 프로퍼티 선언 가능
- 생성자를 통해 초기값 제어 가능

5. 순환 참조란?
- 두 가지 이상의 객체가 서로에 대한 강한 참조 상태를 가지고 있을 떄 발생하는 현상
- 이 상태가 발발하면 서로에 대한 참조가 해제되지 않기때문에 메모리에서 유지되며 메모리 누수(Memory Leak)을 유발한다
- weak, unowned를 통해 해결한다
- 둘다 참조카운트를 올리진 않지만 unowned는 참조 객체가 존재한다는(해제되도 그 주소를 바라봄) 보장된다는 전제가 있기 때문에 weak를 사용하는걸 지향한다

6. defer?
- defer 안에 코드 블럭의 실행을 scope 종료 직전까지 연기 시키는 것(가장 마지막에 호출) 
- Stack 구조이기 때문에 여러개가 선언될 경우 가장 마지막에 작성된 코드블럭 부터 호출된다

7. Queue 자료구조에 대하여
- 기본적으로 FIFO 선입 선출의 성격을 가진 자료구조
- 한쪽 끝에서는 삽입 연산만 반대쪽 끝에서는 삭제만 가능한 구조
- 마트의 계산대줄을 생각해보면 이해가 쉽다
- removeFirst(), append(_:) 등의 함수가 이 구조에서 요구하는 함수와 비슷하다

8. ARC에 대하여 설명
- 자동으로 메모리 관리를 해주는 시스템
- 객체에 대한 참조 카운트를 관리하고 0이 되면 자동으로 메모리를 해제해주는 시스템

8-1. ARC가 구체적으로 어떻게 관리를 하는가?
- 컴파일 단계에 언제 참조되고 해제되는지 분석하고 참조와 해제를 설정한다 이 설정은 런타임때 실행된다
- retain, release를 통해 referenceCount를 증감시키다가 count 가 0이 되면 deinit 을 통해 해제 시킨다
- retain 증가, releases는 감소를 의미한다 

9. 탈출 클로저에 대해서 설명
- @escaping 키워드를 붙여 사용하고 이를 사용하면 인자 값으로 전달된 클로저가 함수 종료 후에도 호출될 수 있도록 하는 것
9-1. 탈출 클로저의 사용 이유
- 비동기 작업으로 함수가 종료되고 난 후 호출할 필요가 있는 클로저를 사용해야 할 때 필요하다

10. 의존성에 대해서 설명
- 함수에 필요한 클래스나 참조 변수에 의존하거나 객체에 영향을 받는 것을 의미한다
- 의존하는 객체가 수정되면 다른 객체도 영향을 받는 것 
10-1. 의존성에서 의존성 주입이란?
- 내부가 아는 외부에서 객체를 생성해서 넣어주는 것을 의미한다
- 객체간의 의존성을 줄이거나 없앨 수 있다
- 객체간의 결합도를 낮추면서 유연한 코드를 작성할 수 있다
10-2. 의존관계 역전 법칙에 대하여
- OOP에서 의존관계 역전 법칙은 소프트웨어 모듈들을 분리하는 특정 형식을 가르킨다
- 상위 계층이 하위 계층의 구현으로부터 독립되게 하여 하위 모듈에 의존해서는 안된다
- 자신보다 변하기 쉬운 것에 의존하지 말아야한다는 법칙
- ex) name 이란 프로퍼티를 가진 Animal이란 Protcol을 만들어서 Dog라는 Class 생성에 의존성 객체를 넣는 것

11. 메모리 구조 중 Stack, Heap에 대하여 설명
11-1. Stack
- 지역변수와 매개변수 등이 저장되는 영역
- 해당 영역에 할당되는 변수는 함수 호출이 완료 후 사라짐
- 컴파일 시 크기 결정
- Value Type이 할당 됨
- LIFO 구조로 NavigationController push/pop 구조와 같다
11-2. Heap
- 개발자가 할당/해제 하는 영역
- Swift에서는 ARC가 자동으로 해제를 해준다(순환참조가 없을 때 한정)
- 런타임시 크기가 결정
- 동적 메모리 할당을 위한 영역
- 메모리 해제가 되지 않거나 순환참조가 발생하면 MemoryLeak(누수)이 발생한다
11-3. Stack과 Heap의 관계에 대하여 설명
- 같은 메모리 영역을 굥유한다
- Stack은 높은 메모리 주소부터 할당 받고 Heap은 낮은 메모리 주소부터 할당 받는다
- 둘다 가변적이다
11-4.Value Type이 Heap에 할당되는 경우는 어떤게 있는가? 
- Collection Type 할당 시 발생
- 두 타입이 섞여있을 때(struct 안에 class를 선언)
- Generic Type인 경우
11-5.Reference Type이 Stack에 저장될 때는 어떤게 있는가?
- final이 적용된 메서드

12. enum / function / closure 각각 어떤 타입인가?
- enum은 Value Type, function/ closure은 Reference Type
12-1. closure이 왜 Reference Type 타입인가?
- closure 값을 Capture하기 때문에

13. Array, Dictionary, Set 등등의 컬렉션 타입은 value type 인가 reference type 인가?
- Value Type이면서 Reference Type이다 기본적으론 Value Type이지만 내부 구현상으론 두 타입이 섞여있다
- Array를 복사할 때마다 많은 값을 다 복사하면 부담이 가기 때문에 CoW(Copy-on-Write)라는 방법을 쓰기 때문이다
13-1 Cow?
- 복사(새로운 할당)이 발생 할 때 원본이나 복사본이 수정되기 전까지는 복사를 하지 않고 Reference Type처럼 참조만 공유하고 수정이 발생할 때 그 때 복사하는 기술을 의미한다
- 이 때문에 Collection Type은 Value Type이면서 Reference Type의 특징을 가지고 있다

14. Swift에서 Optional은 어떻게 구성되어있는가?
- Generic이 적용된 enum으로 some, none case로 구성 값이 없으면 none, 있으면 some(value)로  할당
- !,? 로 표현이 가능하며 if let, guard switch let if case let 등으로 안전하게 추출이 가능하다

15. dynamic에 대한 설명
- Swift와 Objective-C와의 상호운용성(Interoperability)을 위해 사용하는 키워드
- 선언 앞에 사용할 경우 @objc 속성이 암시적으로 표시된다.
- class 맴버에만 사용할 수 있다

16. GCD 에 대해서 설명
- 동시성, 멀티쓰레딩을 쉽게 처리하기 위해 애플에서 재공하는 API
- GCD는 Queue를 이용하여 관리를 하여 들어온 순서대로 Task를 처리한다
16-1. Sync, Async 에 대하여 설명
- Sync(동기)는 다른 Thread로 작업을 보내고 그 작업이 끝날 떄까지 기다린다 해당 작업이 끝나야 다른 작업을 시작할 수 있다
- Sync 요청과 응답이 동시에 발생, 즉 이어폰 하나를 배송주문 했을 시 이어폰이 오기 전까지 아무것도 주문 못하는 상황을 의미
- Async(비동기)는 다른 Thread로 작업을 보내고 그 작업이 끝나는 것을 기다리지 않고 다른 작업을 시작하는 것을 의미힌다
- Async는 이어폰 하나를 배송주문 했을 때 도착을 기다리지 않고 다른 물품도 주문 할 수 있다는 것을 의미
- Sync는 직관적지만 결과가 나올 때까지 대기를 해야하고 Async는 복잡하지만 자원을 효율적으로 사용할 수 있다
16-2. Serial, Concurrent에 대한 설명
- Serial(직렬)은 한번에 하나의 Task만 실행시킬 수 있기 때문에 Queue에 들어온 단일 작업들을 순차적으로 실행시킨다. Async작업이 있다 해도 동시에 요청이 가는게 아닌 먼저 들어온 작업이 끝난 후에 실행 된디 
- Concurrent(병렬)은 몇 개의 쓰레드로 분산할지는 시스템이 정하지만, 시스템이 정한 여러개의 쓰레드로 분산 처리하는 것. 작업들이 각자 독립적이지만 유사한 작업들일 때 굉장히 유용하다.(예를 들면 테이블뷰 셀 같은 것들을 서버에서 받아오는 것)
16-3. Serial == Sync, Concurrent == Async인가?
- Sync는 전후의 작업과 연관성이 없다 즉 단일 작업의 특성을 지칭하는 것이고 앞뒤 작업과는 상관이 없다 단일작업들을 순차적으로 시킬지 말지 정하는 것을 Serial, Concurrent 라고 하는 것이다 Sync의 작업 후에 Async 작업이 들어올 수도 있는 것이다
- Async는 해당 작업의 결과를 기다리지 않는 단일 작업들을 지칭하고 Concurrent는 Queue에 들어온 작업들을 동시다발적으로 실행한다는 개념이다 즉 한번에 여러 개의 Task를 실행시킬 수 있다
 
16-3. UI를 왜 Main Thread에서 업데이트 하는가?(BackGround에서 UI를 제어할 수 없는 이유는?)
- Thread-Safe하지 않은 애플의 의도로 설계되었고 UIKit의 속성을 Thread-Safe하게 설계하면 성능정하가 발생할 수 있기 때문에
- View Drawing Cycle을 생각해보면 하나의 Runloop에서 이를 확인하고 관리하게 된다. 하지만 만약 각 스레드의 Runloop에서 View의 life cycle을 관리하게 되면 화면의 UI가 변경되었을 때 모든 변경사항을 화면에 존재하는 여러 View들이 확인할 수 없게 된다. 따라서 View가 깨질 것이다.
- OS가 UI를 Draw하는 과정 즉 랜더링 프로세스가 발생하는 중에 여러 Thread에서 각자의 View 변경사항을 GPU로 보내면 각각의 정보를 해석해야 하기 떄문에 느려지거나 비효율적이 될 수 있기 떄문에

17. LayoutSubview에 대해서 설명
- Layout을 변경하거나 그릴때 해당 메소드가 호출되며 반영한다 
- UIView는 시스템에게 레이아웃이 변했다고 알려줄 수 있는데 View의 레이아웃이 다시 계산되는 시점에 특정한 작업을 실행 할 수 있게 제공하는 콜백 매서드
17-1. UIView의 Layout 이란?
- 사용자가 보는 화면에서 UIView의 크기와 위치를 의미한다
 
18. 화면 이동에서 ModalPresentationStyle에서 Over가 붙은 키워드의 의미
- Over가 붙으면 Presenting을 시키는 Controller의 계층이 사라지지 않고 계속 존재한다
- WillDisAppear, DidDisAppear가 호출되지 않음
- Over가 빠진 같은 키워는 계층이 사라짐, WillDisAppear, DidDisAppear이 호출됨

19. AutoLayout 설정 시 Leading과 left의 차이점은?
- left는 말 그대로 무조건적인 왼쪽을 의미하고 Leading은 글자의 시작점(가장자리)를 의미한다 
- Leading은 HIG에 맞춰서 글자를 오른쪽에서 왼쪽으로 읽는 국가 설정의 디바이스에서는 오른쪽으로 지정된다

20. CoreData에 대하여 설명
- Database가 아니고 프로그램의 모델 계층의 객체를 관리하는데 사용하는 Framework이자 객체의 라이프 사이클이나 영속성 관리를 위한 기능을 제공하는 객체 그래프 관리자 
20-1. 객체 그래프, 객체 그래프 관리자?
- 메모리에 객체들이 복잡한 관계로 엮여있는 것
- 이 형태를 저장하는 관리자가 객채 그래프 관리자
